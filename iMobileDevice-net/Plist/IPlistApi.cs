//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// <copyright file="IPlistApi.cs" company="Quamotion">
// Copyright (c) 2016-2021 Quamotion. All rights reserved.
// Copyright (c) 2022-2024 Wayne Bonnici.
// </copyright>
#pragma warning disable 1591
#pragma warning disable 1572
#pragma warning disable 1573

namespace iMobileDevice.Plist
{
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using iMobileDevice.iDevice;
    using iMobileDevice.Lockdown;
    using iMobileDevice.Afc;
    using iMobileDevice.Plist;
    
    
    public partial interface IPlistApi
    {
        
        /// <summary>
        /// Gets or sets the <see cref="ILibiMobileDeviceApi"/> which owns this <see cref="Plist"/>.
        /// </summary>
        ILibiMobileDevice Parent
        {
            get;
        }
        
        /// <summary>
        /// Create a new root plist_t type #PLIST_DICT
        /// </summary>
        /// <returns>
        /// the created plist
        /// </returns>
        PlistHandle plist_new_dict();
        
        /// <summary>
        /// Create a new root plist_t type #PLIST_ARRAY
        /// </summary>
        /// <returns>
        /// the created plist
        /// </returns>
        PlistHandle plist_new_array();
        
        /// <summary>
        /// Create a new plist_t type #PLIST_STRING
        /// </summary>
        /// <param name="val">
        /// the sting value, encoded in UTF8.
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        PlistHandle plist_new_string(string val);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_BOOLEAN
        /// </summary>
        /// <param name="val">
        /// the boolean value, 0 is false, other values are true.
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        PlistHandle plist_new_bool(char val);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_INT with an unsigned integer value
        /// </summary>
        /// <param name="val">
        /// the unsigned integer value
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        /// <remarks>
        /// The value is always stored as uint64_t internally.
        /// Use #plist_get_uint_val or #plist_get_int_val to get the unsigned or signed value.
        /// </remarks>
        PlistHandle plist_new_uint(ulong val);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_INT with a signed integer value
        /// </summary>
        /// <param name="val">
        /// the signed integer value
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        /// <remarks>
        /// The value is always stored as uint64_t internally.
        /// Use #plist_get_uint_val or #plist_get_int_val to get the unsigned or signed value.
        /// </remarks>
        PlistHandle plist_new_int(long val);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_REAL
        /// </summary>
        /// <param name="val">
        /// the real value
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        PlistHandle plist_new_real(double val);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_DATA
        /// </summary>
        /// <param name="val">
        /// the binary buffer
        /// </param>
        /// <param name="length">
        /// the length of the buffer
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        PlistHandle plist_new_data(string val, ulong length);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_DATE
        /// </summary>
        /// <param name="sec">
        /// the number of seconds since 01/01/2001
        /// </param>
        /// <param name="usec">
        /// the number of microseconds
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        PlistHandle plist_new_date(int sec, int usec);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_UID
        /// </summary>
        /// <param name="val">
        /// the unsigned integer value
        /// </param>
        /// <returns>
        /// the created item
        /// </returns>
        PlistHandle plist_new_uid(ulong val);
        
        /// <summary>
        /// Create a new plist_t type #PLIST_NULL
        /// </summary>
        /// <returns>
        /// the created item
        /// </returns>
        /// <remarks>
        /// This type is not valid for all formats, e.g. the XML format
        /// does not support it.
        /// </remarks>
        PlistHandle plist_new_null();
        
        /// <summary>
        /// Destruct a plist_t node and all its children recursively
        /// </summary>
        /// <param name="plist">
        /// the plist to free
        /// </param>
        void plist_free(System.IntPtr plist);
        
        /// <summary>
        /// Return a copy of passed node and it's children
        /// </summary>
        /// <param name="node">
        /// the plist to copy
        /// </param>
        /// <returns>
        /// copied plist
        /// </returns>
        PlistHandle plist_copy(PlistHandle node);
        
        /// <summary>
        /// Get size of a #PLIST_ARRAY node.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_ARRAY
        /// </param>
        /// <returns>
        /// size of the #PLIST_ARRAY node
        /// </returns>
        uint plist_array_get_size(PlistHandle node);
        
        /// <summary>
        /// Get the nth item in a #PLIST_ARRAY node.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_ARRAY
        /// </param>
        /// <param name="n">
        /// the index of the item to get. Range is [0, array_size[
        /// </param>
        /// <returns>
        /// the nth item or NULL if node is not of type #PLIST_ARRAY
        /// </returns>
        PlistHandle plist_array_get_item(PlistHandle node, uint n);
        
        /// <summary>
        /// Get the index of an item. item must be a member of a #PLIST_ARRAY node.
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <returns>
        /// the node index or UINT_MAX if node index can't be determined
        /// </returns>
        uint plist_array_get_item_index(PlistHandle node);
        
        /// <summary>
        /// Set the nth item in a #PLIST_ARRAY node.
        /// The previous item at index n will be freed using #plist_free
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_ARRAY
        /// </param>
        /// <param name="item">
        /// the new item at index n. The array is responsible for freeing item when it is no longer needed.
        /// </param>
        /// <param name="n">
        /// the index of the item to get. Range is [0, array_size[. Assert if n is not in range.
        /// </param>
        void plist_array_set_item(PlistHandle node, PlistHandle item, uint n);
        
        /// <summary>
        /// Append a new item at the end of a #PLIST_ARRAY node.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_ARRAY
        /// </param>
        /// <param name="item">
        /// the new item. The array is responsible for freeing item when it is no longer needed.
        /// </param>
        void plist_array_append_item(PlistHandle node, PlistHandle item);
        
        /// <summary>
        /// Insert a new item at position n in a #PLIST_ARRAY node.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_ARRAY
        /// </param>
        /// <param name="item">
        /// the new item to insert. The array is responsible for freeing item when it is no longer needed.
        /// </param>
        /// <param name="n">
        /// The position at which the node will be stored. Range is [0, array_size[. Assert if n is not in range.
        /// </param>
        void plist_array_insert_item(PlistHandle node, PlistHandle item, uint n);
        
        /// <summary>
        /// Remove an existing position in a #PLIST_ARRAY node.
        /// Removed position will be freed using #plist_free.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_ARRAY
        /// </param>
        /// <param name="n">
        /// The position to remove. Range is [0, array_size[. Assert if n is not in range.
        /// </param>
        void plist_array_remove_item(PlistHandle node, uint n);
        
        /// <summary>
        /// Remove a node that is a child node of a #PLIST_ARRAY node.
        /// node will be freed using #plist_free.
        /// </summary>
        /// <param name="node">
        /// The node to be removed from its #PLIST_ARRAY parent.
        /// </param>
        void plist_array_item_remove(PlistHandle node);
        
        /// <summary>
        /// Create an iterator of a #PLIST_ARRAY node.
        /// The allocated iterator should be freed with the standard free function.
        /// </summary>
        /// <param name="node">
        /// The node of type #PLIST_ARRAY
        /// </param>
        /// <param name="iter">
        /// Location to store the iterator for the array.
        /// </param>
        void plist_array_new_iter(PlistHandle node, out PlistArrayIterHandle iter);
        
        /// <summary>
        /// Increment iterator of a #PLIST_ARRAY node.
        /// </summary>
        /// <param name="node">
        /// The node of type #PLIST_ARRAY.
        /// </param>
        /// <param name="iter">
        /// Iterator of the array
        /// </param>
        /// <param name="item">
        /// Location to store the item. The caller must *not* free the
        /// returned item. Will be set to NULL when no more items are left
        /// to iterate.
        /// </param>
        void plist_array_next_item(PlistHandle node, PlistArrayIterHandle iter, out PlistHandle item);
        
        /// <summary>
        /// Get size of a #PLIST_DICT node.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_DICT
        /// </param>
        /// <returns>
        /// size of the #PLIST_DICT node
        /// </returns>
        uint plist_dict_get_size(PlistHandle node);
        
        /// <summary>
        /// Create an iterator of a #PLIST_DICT node.
        /// The allocated iterator should be freed with the standard free function.
        /// </summary>
        /// <param name="node">
        /// The node of type #PLIST_DICT.
        /// </param>
        /// <param name="iter">
        /// Location to store the iterator for the dictionary.
        /// </param>
        void plist_dict_new_iter(PlistHandle node, out PlistDictIterHandle iter);
        
        /// <summary>
        /// Increment iterator of a #PLIST_DICT node.
        /// </summary>
        /// <param name="node">
        /// The node of type #PLIST_DICT
        /// </param>
        /// <param name="iter">
        /// Iterator of the dictionary
        /// </param>
        /// <param name="key">
        /// Location to store the key, or NULL. The caller is responsible
        /// for freeing the the returned string.
        /// </param>
        /// <param name="val">
        /// Location to store the value, or NULL. The caller must *not*
        /// free the returned value. Will be set to NULL when no more
        /// key/value pairs are left to iterate.
        /// </param>
        void plist_dict_next_item(PlistHandle node, PlistDictIterHandle iter, out string key, out PlistHandle val);
        
        /// <summary>
        /// Get key associated key to an item. Item must be member of a dictionary.
        /// </summary>
        /// <param name="node">
        /// the item
        /// </param>
        /// <param name="key">
        /// a location to store the key. The caller is responsible for freeing the returned string.
        /// </param>
        void plist_dict_get_item_key(PlistHandle node, out string key);
        
        /// <summary>
        /// Get the nth item in a #PLIST_DICT node.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_DICT
        /// </param>
        /// <param name="key">
        /// the identifier of the item to get.
        /// </param>
        /// <returns>
        /// the item or NULL if node is not of type #PLIST_DICT. The caller should not free
        /// the returned node.
        /// </returns>
        PlistHandle plist_dict_get_item(PlistHandle node, string key);
        
        /// <summary>
        /// Get key node associated to an item. Item must be member of a dictionary.
        /// </summary>
        /// <param name="node">
        /// the item
        /// </param>
        /// <returns>
        /// the key node of the given item, or NULL.
        /// </returns>
        PlistHandle plist_dict_item_get_key(PlistHandle node);
        
        /// <summary>
        /// Set item identified by key in a #PLIST_DICT node.
        /// The previous item identified by key will be freed using #plist_free.
        /// If there is no item for the given key a new item will be inserted.
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_DICT
        /// </param>
        /// <param name="item">
        /// the new item associated to key
        /// </param>
        /// <param name="key">
        /// the identifier of the item to set.
        /// </param>
        void plist_dict_set_item(PlistHandle node, string key, PlistHandle item);
        
        /// <summary>
        /// Remove an existing position in a #PLIST_DICT node.
        /// Removed position will be freed using #plist_free
        /// </summary>
        /// <param name="node">
        /// the node of type #PLIST_DICT
        /// </param>
        /// <param name="key">
        /// The identifier of the item to remove. Assert if identifier is not present.
        /// </param>
        void plist_dict_remove_item(PlistHandle node, string key);
        
        /// <summary>
        /// Merge a dictionary into another. This will add all key/value pairs
        /// from the source dictionary to the target dictionary, overwriting
        /// any existing key/value pairs that are already present in target.
        /// </summary>
        /// <param name="target">
        /// pointer to an existing node of type #PLIST_DICT
        /// </param>
        /// <param name="source">
        /// node of type #PLIST_DICT that should be merged into target
        /// </param>
        void plist_dict_merge(out PlistHandle target, PlistHandle source);
        
        /// <summary>
        /// Get a boolean value from a given #PLIST_DICT entry.
        /// The value node can be of type #PLIST_BOOLEAN, but also
        /// #PLIST_STRING (either 'true' or 'false'),
        /// #PLIST_INT with a numerical value of 0 or >= 1,
        /// or #PLIST_DATA with a single byte with a value of 0 or >= 1.
        /// </summary>
        /// <param name="dict">
        /// A node of type #PLIST_DICT
        /// </param>
        /// <param name="key">
        /// The key to look for in dict
        /// </param>
        /// <returns>
        /// 0 or 1 depending on the value of the node.
        /// </returns>
        /// <remarks>
        /// This function returns 0 if the dictionary does not contain an
        /// entry for the given key, if the value node is of any other than
        /// the above mentioned type, or has any mismatching value.
        /// </remarks>
        char plist_dict_get_bool(PlistHandle dict, string key);
        
        /// <summary>
        /// Get a signed integer value from a given #PLIST_DICT entry.
        /// The value node can be of type #PLIST_INT, but also
        /// #PLIST_STRING with a numerical value as string (decimal or hexadecimal),
        /// or #PLIST_DATA with a size of 1, 2, 4, or 8 bytes in little endian byte order.
        /// </summary>
        /// <param name="dict">
        /// A node of type #PLIST_DICT
        /// </param>
        /// <param name="key">
        /// The key to look for in dict
        /// </param>
        /// <returns>
        /// Signed integer value depending on the value of the node.
        /// </returns>
        /// <remarks>
        /// This function returns 0 if the dictionary does not contain an
        /// entry for the given key, if the value node is of any other than
        /// the above mentioned type, or has any mismatching value.
        /// </remarks>
        long plist_dict_get_int(PlistHandle dict, string key);
        
        /// <summary>
        /// Get an unsigned integer value from a given #PLIST_DICT entry.
        /// The value node can be of type #PLIST_INT, but also
        /// #PLIST_STRING with a numerical value as string (decimal or hexadecimal),
        /// or #PLIST_DATA with a size of 1, 2, 4, or 8 bytes in little endian byte order.
        /// </summary>
        /// <param name="dict">
        /// A node of type #PLIST_DICT
        /// </param>
        /// <param name="key">
        /// The key to look for in dict
        /// </param>
        /// <returns>
        /// Signed integer value depending on the value of the node.
        /// </returns>
        /// <remarks>
        /// This function returns 0 if the dictionary does not contain an
        /// entry for the given key, if the value node is of any other than
        /// the above mentioned type, or has any mismatching value.
        /// </remarks>
        ulong plist_dict_get_uint(PlistHandle dict, string key);
        
        /// <summary>
        /// Copy a node from *source_dict* to *target_dict*.
        /// The node is looked up in *source_dict* with given *key*, unless *alt_source_key*
        /// is non-NULL, in which case it is looked up with *alt_source_key*.
        /// The entry in *target_dict* is **always** created with *key*.
        /// </summary>
        /// <param name="targetDict">
        /// The target dictionary to copy to.
        /// </param>
        /// <param name="sourceDict">
        /// The source dictionary to copy from.
        /// </param>
        /// <param name="key">
        /// The key for the node to copy.
        /// </param>
        /// <param name="altSourceKey">
        /// The alternative source key for lookup in *source_dict* or NULL.
        /// </param>
        PlistError plist_dict_copy_item(PlistHandle targetDict, PlistHandle sourceDict, string key, string altSourceKey);
        
        /// <summary>
        /// Copy a boolean value from *source_dict* to *target_dict*.
        /// The node is looked up in *source_dict* with given *key*, unless *alt_source_key*
        /// is non-NULL, in which case it is looked up with *alt_source_key*.
        /// The entry in *target_dict* is **always** created with *key*.
        /// </summary>
        /// <param name="targetDict">
        /// The target dictionary to copy to.
        /// </param>
        /// <param name="sourceDict">
        /// The source dictionary to copy from.
        /// </param>
        /// <param name="key">
        /// The key for the node to copy.
        /// </param>
        /// <param name="altSourceKey">
        /// The alternative source key for lookup in *source_dict* or NULL.
        /// </param>
        /// <remarks>
        /// The boolean value from *source_dict* is retrieved with #plist_dict_get_bool,
        /// but is **always** created as #PLIST_BOOLEAN in *target_dict*.
        /// </remarks>
        PlistError plist_dict_copy_bool(PlistHandle targetDict, PlistHandle sourceDict, string key, string altSourceKey);
        
        /// <summary>
        /// Copy a signed integer value from *source_dict* to *target_dict*.
        /// The node is looked up in *source_dict* with given *key*, unless *alt_source_key*
        /// is non-NULL, in which case it is looked up with *alt_source_key*.
        /// The entry in *target_dict* is **always** created with *key*.
        /// </summary>
        /// <param name="targetDict">
        /// The target dictionary to copy to.
        /// </param>
        /// <param name="sourceDict">
        /// The source dictionary to copy from.
        /// </param>
        /// <param name="key">
        /// The key for the node value to copy.
        /// </param>
        /// <param name="altSourceKey">
        /// The alternative source key for lookup in *source_dict* or NULL.
        /// </param>
        /// <remarks>
        /// The signed integer value from *source_dict* is retrieved with #plist_dict_get_int,
        /// but is **always** created as #PLIST_INT.
        /// </remarks>
        PlistError plist_dict_copy_int(PlistHandle targetDict, PlistHandle sourceDict, string key, string altSourceKey);
        
        /// <summary>
        /// Copy an unsigned integer value from *source_dict* to *target_dict*.
        /// The node is looked up in *source_dict* with given *key*, unless *alt_source_key*
        /// is non-NULL, in which case it is looked up with *alt_source_key*.
        /// The entry in *target_dict* is **always** created with *key*.
        /// </summary>
        /// <param name="targetDict">
        /// The target dictionary to copy to.
        /// </param>
        /// <param name="sourceDict">
        /// The source dictionary to copy from.
        /// </param>
        /// <param name="key">
        /// The key for the node value to copy.
        /// </param>
        /// <param name="altSourceKey">
        /// The alternative source key for lookup in *source_dict* or NULL.
        /// </param>
        /// <remarks>
        /// The unsigned integer value from *source_dict* is retrieved with #plist_dict_get_uint,
        /// but is **always** created as #PLIST_INT.
        /// </remarks>
        PlistError plist_dict_copy_uint(PlistHandle targetDict, PlistHandle sourceDict, string key, string altSourceKey);
        
        /// <summary>
        /// Copy a #PLIST_DATA node from *source_dict* to *target_dict*.
        /// The node is looked up in *source_dict* with given *key*, unless *alt_source_key*
        /// is non-NULL, in which case it is looked up with *alt_source_key*.
        /// The entry in *target_dict* is **always** created with *key*.
        /// </summary>
        /// <param name="targetDict">
        /// The target dictionary to copy to.
        /// </param>
        /// <param name="sourceDict">
        /// The source dictionary to copy from.
        /// </param>
        /// <param name="key">
        /// The key for the node value to copy.
        /// </param>
        /// <param name="altSourceKey">
        /// The alternative source key for lookup in *source_dict* or NULL.
        /// </param>
        /// <remarks>
        /// This function is like #plist_dict_copy_item, except that it fails
        /// if the source node is not of type #PLIST_DATA.
        /// </remarks>
        PlistError plist_dict_copy_data(PlistHandle targetDict, PlistHandle sourceDict, string key, string altSourceKey);
        
        /// <summary>
        /// Copy a #PLIST_STRING node from *source_dict* to *target_dict*.
        /// The node is looked up in *source_dict* with given *key*, unless *alt_source_key*
        /// is non-NULL, in which case it is looked up with *alt_source_key*.
        /// The entry in *target_dict* is **always** created with *key*.
        /// </summary>
        /// <param name="targetDict">
        /// The target dictionary to copy to.
        /// </param>
        /// <param name="sourceDict">
        /// The source dictionary to copy from.
        /// </param>
        /// <param name="key">
        /// The key for the node value to copy.
        /// </param>
        /// <param name="altSourceKey">
        /// The alternative source key for lookup in *source_dict* or NULL.
        /// </param>
        /// <remarks>
        /// This function is like #plist_dict_copy_item, except that it fails
        /// if the source node is not of type #PLIST_STRING.
        /// </remarks>
        PlistError plist_dict_copy_string(PlistHandle targetDict, PlistHandle sourceDict, string key, string altSourceKey);
        
        /// <summary>
        /// Get the parent of a node
        /// </summary>
        /// <param name="node">
        /// the parent (NULL if node is root)
        /// </param>
        PlistHandle plist_get_parent(PlistHandle node);
        
        /// <summary>
        /// Get the #plist_type of a node.
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <returns>
        /// the type of the node
        /// </returns>
        PlistType plist_get_node_type(PlistHandle node);
        
        /// <summary>
        /// Get the value of a #PLIST_KEY node.
        /// This function does nothing if node is not of type #PLIST_KEY
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a C-string. This function allocates the memory,
        /// caller is responsible for freeing it.
        /// </param>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        void plist_get_key_val(PlistHandle node, out string val);
        
        /// <summary>
        /// Get the value of a #PLIST_STRING node.
        /// This function does nothing if node is not of type #PLIST_STRING
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a C-string. This function allocates the memory,
        /// caller is responsible for freeing it. Data is UTF-8 encoded.
        /// </param>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        void plist_get_string_val(PlistHandle node, out string val);
        
        /// <summary>
        /// Get a pointer to the buffer of a #PLIST_STRING node.
        /// </summary>
        /// <param name="node">
        /// The node
        /// </param>
        /// <param name="length">
        /// If non-NULL, will be set to the length of the string
        /// </param>
        /// <returns>
        /// Pointer to the NULL-terminated buffer.
        /// </returns>
        /// <remarks>
        /// DO NOT MODIFY the buffer. Mind that the buffer is only available
        /// until the plist node gets freed. Make a copy if needed.
        /// </remarks>
        System.IntPtr plist_get_string_ptr(PlistHandle node, ref ulong length);
        
        /// <summary>
        /// Get the value of a #PLIST_BOOLEAN node.
        /// This function does nothing if node is not of type #PLIST_BOOLEAN
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a uint8_t variable.
        /// </param>
        void plist_get_bool_val(PlistHandle node, ref char val);
        
        /// <summary>
        /// Get the unsigned integer value of a #PLIST_INT node.
        /// This function does nothing if node is not of type #PLIST_INT
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a uint64_t variable.
        /// </param>
        void plist_get_uint_val(PlistHandle node, ref ulong val);
        
        /// <summary>
        /// Get the signed integer value of a #PLIST_INT node.
        /// This function does nothing if node is not of type #PLIST_INT
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a int64_t variable.
        /// </param>
        void plist_get_int_val(PlistHandle node, ref long val);
        
        /// <summary>
        /// Get the value of a #PLIST_REAL node.
        /// This function does nothing if node is not of type #PLIST_REAL
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a double variable.
        /// </param>
        void plist_get_real_val(PlistHandle node, ref double val);
        
        /// <summary>
        /// Get the value of a #PLIST_DATA node.
        /// This function does nothing if node is not of type #PLIST_DATA
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to an unallocated char buffer. This function allocates the memory,
        /// caller is responsible for freeing it.
        /// </param>
        /// <param name="length">
        /// the length of the buffer
        /// </param>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        void plist_get_data_val(PlistHandle node, out string val, ref ulong length);
        
        /// <summary>
        /// Get a pointer to the data buffer of a #PLIST_DATA node.
        /// </summary>
        /// <param name="node">
        /// The node
        /// </param>
        /// <param name="length">
        /// Pointer to a uint64_t that will be set to the length of the buffer
        /// </param>
        /// <returns>
        /// Pointer to the buffer
        /// </returns>
        /// <remarks>
        /// DO NOT MODIFY the buffer. Mind that the buffer is only available
        /// until the plist node gets freed. Make a copy if needed.
        /// </remarks>
        System.IntPtr plist_get_data_ptr(PlistHandle node, ref ulong length);
        
        /// <summary>
        /// Get the value of a #PLIST_DATE node.
        /// This function does nothing if node is not of type #PLIST_DATE
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="sec">
        /// a pointer to an int32_t variable. Represents the number of seconds since 01/01/2001.
        /// </param>
        /// <param name="usec">
        /// a pointer to an int32_t variable. Represents the number of microseconds
        /// </param>
        void plist_get_date_val(PlistHandle node, ref int sec, ref int usec);
        
        /// <summary>
        /// Get the value of a #PLIST_UID node.
        /// This function does nothing if node is not of type #PLIST_UID
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// a pointer to a uint64_t variable.
        /// </param>
        void plist_get_uid_val(PlistHandle node, ref ulong val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_KEY
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the key value
        /// </param>
        void plist_set_key_val(PlistHandle node, string val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_STRING
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the string value. The string is copied when set and will be
        /// freed by the node.
        /// </param>
        void plist_set_string_val(PlistHandle node, string val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_BOOLEAN
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the boolean value
        /// </param>
        void plist_set_bool_val(PlistHandle node, char val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_INT
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the unsigned integer value
        /// </param>
        void plist_set_uint_val(PlistHandle node, ulong val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_INT
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the signed integer value
        /// </param>
        void plist_set_int_val(PlistHandle node, long val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_REAL
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the real value
        /// </param>
        void plist_set_real_val(PlistHandle node, double val);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_DATA
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the binary buffer. The buffer is copied when set and will
        /// be freed by the node.
        /// </param>
        /// <param name="length">
        /// the length of the buffer
        /// </param>
        void plist_set_data_val(PlistHandle node, string val, ulong length);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_DATE
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="sec">
        /// the number of seconds since 01/01/2001
        /// </param>
        /// <param name="usec">
        /// the number of microseconds
        /// </param>
        void plist_set_date_val(PlistHandle node, int sec, int usec);
        
        /// <summary>
        /// Set the value of a node.
        /// Forces type of node to #PLIST_UID
        /// </summary>
        /// <param name="node">
        /// the node
        /// </param>
        /// <param name="val">
        /// the unsigned integer value
        /// </param>
        void plist_set_uid_val(PlistHandle node, ulong val);
        
        /// <summary>
        /// Export the #plist_t structure to XML format.
        /// </summary>
        /// <param name="plist">
        /// the root node to export
        /// </param>
        /// <param name="plistXml">
        /// a pointer to a C-string. This function allocates the memory,
        /// caller is responsible for freeing it. Data is UTF-8 encoded.
        /// </param>
        /// <param name="length">
        /// a pointer to an uint32_t variable. Represents the length of the allocated buffer.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        PlistError plist_to_xml(PlistHandle plist, out string plistXml, ref uint length);
        
        /// <summary>
        /// Export the #plist_t structure to binary format.
        /// </summary>
        /// <param name="plist">
        /// the root node to export
        /// </param>
        /// <param name="plistBin">
        /// a pointer to a char* buffer. This function allocates the memory,
        /// caller is responsible for freeing it.
        /// </param>
        /// <param name="length">
        /// a pointer to an uint32_t variable. Represents the length of the allocated buffer.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        PlistError plist_to_bin(PlistHandle plist, out string plistBin, ref uint length);
        
        /// <summary>
        /// Export the #plist_t structure to JSON format.
        /// </summary>
        /// <param name="plist">
        /// the root node to export
        /// </param>
        /// <param name="plistJson">
        /// a pointer to a char* buffer. This function allocates the memory,
        /// caller is responsible for freeing it.
        /// </param>
        /// <param name="length">
        /// a pointer to an uint32_t variable. Represents the length of the allocated buffer.
        /// </param>
        /// <param name="prettify">
        /// pretty print the output if != 0
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        PlistError plist_to_json(PlistHandle plist, out string plistJson, ref uint length, int prettify);
        
        /// <summary>
        /// Export the #plist_t structure to OpenStep format.
        /// </summary>
        /// <param name="plist">
        /// the root node to export
        /// </param>
        /// <param name="plistOpenstep">
        /// a pointer to a char* buffer. This function allocates the memory,
        /// caller is responsible for freeing it.
        /// </param>
        /// <param name="length">
        /// a pointer to an uint32_t variable. Represents the length of the allocated buffer.
        /// </param>
        /// <param name="prettify">
        /// pretty print the output if != 0
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        PlistError plist_to_openstep(PlistHandle plist, out string plistOpenstep, ref uint length, int prettify);
        
        /// <summary>
        /// Import the #plist_t structure from XML format.
        /// </summary>
        /// <param name="plistXml">
        /// a pointer to the xml buffer.
        /// </param>
        /// <param name="length">
        /// length of the buffer to read.
        /// </param>
        /// <param name="plist">
        /// a pointer to the imported plist.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        PlistError plist_from_xml(string plistXml, uint length, out PlistHandle plist);
        
        /// <summary>
        /// Import the #plist_t structure from binary format.
        /// </summary>
        /// <param name="plistBin">
        /// a pointer to the xml buffer.
        /// </param>
        /// <param name="length">
        /// length of the buffer to read.
        /// </param>
        /// <param name="plist">
        /// a pointer to the imported plist.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        PlistError plist_from_bin(string plistBin, uint length, out PlistHandle plist);
        
        /// <summary>
        /// Import the #plist_t structure from JSON format.
        /// </summary>
        /// <param name="json">
        /// a pointer to the JSON buffer.
        /// </param>
        /// <param name="length">
        /// length of the buffer to read.
        /// </param>
        /// <param name="plist">
        /// a pointer to the imported plist.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        PlistError plist_from_json(string json, uint length, out PlistHandle plist);
        
        /// <summary>
        /// Import the #plist_t structure from OpenStep plist format.
        /// </summary>
        /// <param name="openstep">
        /// a pointer to the OpenStep plist buffer.
        /// </param>
        /// <param name="length">
        /// length of the buffer to read.
        /// </param>
        /// <param name="plist">
        /// a pointer to the imported plist.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        PlistError plist_from_openstep(string openstep, uint length, out PlistHandle plist);
        
        /// <summary>
        /// Import the #plist_t structure from memory data.
        /// This function will look at the first bytes of plist_data
        /// to determine if plist_data contains a binary, JSON, OpenStep, or XML plist
        /// and tries to parse the data in the appropriate format.
        /// </summary>
        /// <param name="plistData">
        /// A pointer to the memory buffer containing plist data.
        /// </param>
        /// <param name="length">
        /// Length of the buffer to read.
        /// </param>
        /// <param name="plist">
        /// A pointer to the imported plist.
        /// </param>
        /// <param name="format">
        /// If non-NULL, the #plist_format_t value pointed to will be set to the parsed format.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        /// <remarks>
        /// This is just a convenience function and the format detection is
        /// very basic. It checks with plist_is_binary() if the data supposedly
        /// contains binary plist data, if not it checks if the first bytes have
        /// either '{' or '[' and assumes JSON format, and XML tags will result
        /// in parsing as XML, otherwise it will try to parse as OpenStep.
        /// </remarks>
        PlistError plist_from_memory(string plistData, uint length, out PlistHandle plist, ref PlistFormat format);
        
        /// <summary>
        /// Import the #plist_t structure directly from file.
        /// This function will look at the first bytes of the file data
        /// to determine if it contains a binary, JSON, OpenStep, or XML plist
        /// and tries to parse the data in the appropriate format.
        /// Uses plist_from_memory() internally.
        /// </summary>
        /// <param name="filename">
        /// The name of the file to parse.
        /// </param>
        /// <param name="plist">
        /// A pointer to the imported plist.
        /// </param>
        /// <param name="format">
        /// If non-NULL, the #plist_format_t value pointed to will be set to the parsed format.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure
        /// </returns>
        PlistError plist_read_from_file(string filename, out PlistHandle plist, ref PlistFormat format);
        
        /// <summary>
        /// Write the #plist_t structure to a NULL-terminated string using the given format and options.
        /// </summary>
        /// <param name="plist">
        /// The input plist structure
        /// </param>
        /// <param name="output">
        /// Pointer to a char* buffer. This function allocates the memory,
        /// caller is responsible for freeing it.
        /// </param>
        /// <param name="length">
        /// A pointer to a uint32_t value that will receive the lenght of the allocated buffer.
        /// </param>
        /// <param name="format">
        /// A #plist_format_t value that specifies the output format to use.
        /// </param>
        /// <param name="options">
        /// One or more bitwise ORed values of #plist_write_options_t.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.
        /// </returns>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// #PLIST_FORMAT_BINARY is not supported by this function.
        /// </remarks>
        PlistError plist_write_to_string(PlistHandle plist, out string output, ref uint length, PlistFormat format, PlistWriteOptions options);
        
        /// <summary>
        /// Write the #plist_t structure to a FILE* stream using the given format and options.
        /// </summary>
        /// <param name="plist">
        /// The input plist structure
        /// </param>
        /// <param name="stream">
        /// A writeable FILE* stream that the data will be written to.
        /// </param>
        /// <param name="format">
        /// A #plist_format_t value that specifies the output format to use.
        /// </param>
        /// <param name="options">
        /// One or more bitwise ORed values of #plist_write_options_t.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.
        /// </returns>
        /// <remarks>
        /// While this function allows all formats to be written to the given stream,
        /// only the formats #PLIST_FORMAT_PRINT, #PLIST_FORMAT_LIMD, and #PLIST_FORMAT_PLUTIL
        /// (basically all output-only formats) are directly and efficiently written to the stream;
        /// the other formats are written to a memory buffer first.
        /// </remarks>
        PlistError plist_write_to_stream(PlistHandle plist, FilePtrHandle stream, PlistFormat format, PlistWriteOptions options);
        
        /// <summary>
        /// Write the #plist_t structure to a file at given path using the given format and options.
        /// </summary>
        /// <param name="plist">
        /// The input plist structure
        /// </param>
        /// <param name="filename">
        /// The file name of the file to write to. Existing files will be overwritten.
        /// </param>
        /// <param name="format">
        /// A #plist_format_t value that specifies the output format to use.
        /// </param>
        /// <param name="options">
        /// One or more bitwise ORed values of #plist_write_options_t.
        /// </param>
        /// <returns>
        /// PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.
        /// </returns>
        /// <remarks>
        /// Use plist_mem_free() to free the allocated memory.
        /// </remarks>
        PlistError plist_write_to_file(PlistHandle plist, string filename, PlistFormat format, PlistWriteOptions options);
        
        /// <summary>
        /// Print the given plist in human-readable format to standard output.
        /// This is equivalent to
        /// plist_write_to_stream(plist, stdout, PLIST_FORMAT_PRINT, PLIST_OPT_PARTIAL_DATA);
        /// </summary>
        /// <param name="plist">
        /// The #plist_t structure to print
        /// </param>
        /// <remarks>
        /// For #PLIST_DATA nodes, only a maximum of 24 bytes (first 16 and last 8) are written.
        /// </remarks>
        void plist_print(PlistHandle plist);
        
        /// <summary>
        /// Test if in-memory plist data is in binary format.
        /// This function will look at the first bytes of plist_data to determine
        /// if it supposedly contains a binary plist.
        /// </summary>
        /// <param name="plistData">
        /// a pointer to the memory buffer containing plist data.
        /// </param>
        /// <param name="length">
        /// length of the buffer to read.
        /// </param>
        /// <returns>
        /// 1 if the buffer is a binary plist, 0 otherwise.
        /// </returns>
        /// <remarks>
        /// The function is not validating the whole memory buffer to check
        /// if the content is truly a plist, it is only using some heuristic on
        /// the first few bytes of plist_data.
        /// </remarks>
        int plist_is_binary(string plistData, uint length);
        
        /// <summary>
        /// Get a node from its path. Each path element depends on the associated father node type.
        /// For Dictionaries, var args are casted to const char*, for arrays, var args are caster to uint32_t
        /// Search is breath first order.
        /// </summary>
        /// <param name="plist">
        /// the node to access result from.
        /// </param>
        /// <param name="length">
        /// length of the path to access
        /// </param>
        /// <returns>
        /// the value to access.
        /// </returns>
        PlistHandle plist_access_path(PlistHandle plist, uint length);
        
        /// <summary>
        /// Variadic version of #plist_access_path.
        /// </summary>
        /// <param name="plist">
        /// the node to access result from.
        /// </param>
        /// <param name="length">
        /// length of the path to access
        /// </param>
        /// <param name="v">
        /// list of array's index and dic'st key
        /// </param>
        /// <returns>
        /// the value to access.
        /// </returns>
        PlistHandle plist_access_pathv(PlistHandle plist, uint length, System.IntPtr v);
        
        /// <summary>
        /// Compare two node values
        /// </summary>
        /// <param name="nodeL">
        /// left node to compare
        /// </param>
        /// <param name="nodeR">
        /// rigth node to compare
        /// </param>
        /// <returns>
        /// TRUE is type and value match, FALSE otherwise.
        /// </returns>
        sbyte plist_compare_node_value(PlistHandle nodeL, PlistHandle nodeR);
        
        /// <summary>
        /// Helper function to check the value of a PLIST_BOOL node.
        /// </summary>
        /// <param name="boolnode">
        /// node of type PLIST_BOOL
        /// </param>
        /// <returns>
        /// 1 if the boolean node has a value of TRUE or 0 if FALSE.
        /// </returns>
        int plist_bool_val_is_true(PlistHandle boolnode);
        
        /// <summary>
        /// Helper function to test if a given #PLIST_INT node's value is negative
        /// </summary>
        /// <param name="intnode">
        /// node of type PLIST_INT
        /// </param>
        /// <returns>
        /// 1 if the node's value is negative, or 0 if positive.
        /// </returns>
        int plist_int_val_is_negative(PlistHandle intnode);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_INT node against
        /// a given signed integer value.
        /// </summary>
        /// <param name="uintnode">
        /// node of type PLIST_INT
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// 1 if the node's value is greater than cmpval,
        /// or -1 if the node's value is less than cmpval.
        /// </returns>
        int plist_int_val_compare(PlistHandle uintnode, long cmpval);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_INT node against
        /// a given unsigned integer value.
        /// </summary>
        /// <param name="uintnode">
        /// node of type PLIST_INT
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// 1 if the node's value is greater than cmpval,
        /// or -1 if the node's value is less than cmpval.
        /// </returns>
        int plist_uint_val_compare(PlistHandle uintnode, ulong cmpval);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_UID node against
        /// a given value.
        /// </summary>
        /// <param name="uidnode">
        /// node of type PLIST_UID
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// 1 if the node's value is greater than cmpval,
        /// or -1 if the node's value is less than cmpval.
        /// </returns>
        int plist_uid_val_compare(PlistHandle uidnode, ulong cmpval);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_REAL node against
        /// a given value.
        /// </summary>
        /// <param name="realnode">
        /// node of type PLIST_REAL
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are (almost) equal,
        /// 1 if the node's value is greater than cmpval,
        /// or -1 if the node's value is less than cmpval.
        /// </returns>
        /// <remarks>
        /// WARNING: Comparing floating point values can give inaccurate
        /// results because of the nature of floating point values on computer
        /// systems. While this function is designed to be as accurate as
        /// possible, please don't rely on it too much.
        /// </remarks>
        int plist_real_val_compare(PlistHandle realnode, double cmpval);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_DATE node against
        /// a given set of seconds and fraction of a second since epoch.
        /// </summary>
        /// <param name="datenode">
        /// node of type PLIST_DATE
        /// </param>
        /// <param name="cmpsec">
        /// number of seconds since epoch to compare against
        /// </param>
        /// <param name="cmpusec">
        /// fraction of a second in microseconds to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's date is equal to the supplied values,
        /// 1 if the node's date is greater than the supplied values,
        /// or -1 if the node's date is less than the supplied values.
        /// </returns>
        int plist_date_val_compare(PlistHandle datenode, int cmpsec, int cmpusec);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_STRING node against
        /// a given value.
        /// This function basically behaves like strcmp.
        /// </summary>
        /// <param name="strnode">
        /// node of type PLIST_STRING
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// > 0 if the node's value is lexicographically greater than cmpval,
        /// or
        /// <
        /// 0 if the node's value is lexicographically less than cmpval.
        /// </returns>
        int plist_string_val_compare(PlistHandle strnode, string cmpval);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_STRING node against
        /// a given value, while not comparing more than n characters.
        /// This function basically behaves like strncmp.
        /// </summary>
        /// <param name="strnode">
        /// node of type PLIST_STRING
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <param name="n">
        /// maximum number of characters to compare
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// > 0 if the node's value is lexicographically greater than cmpval,
        /// or
        /// <
        /// 0 if the node's value is lexicographically less than cmpval.
        /// </returns>
        int plist_string_val_compare_with_size(PlistHandle strnode, string cmpval, uint n);
        
        /// <summary>
        /// Helper function to match a given substring in the value of a
        /// PLIST_STRING node.
        /// </summary>
        /// <param name="strnode">
        /// node of type PLIST_STRING
        /// </param>
        /// <param name="substr">
        /// value to match
        /// </param>
        /// <returns>
        /// 1 if the node's value contains the given substring,
        /// or 0 if not.
        /// </returns>
        int plist_string_val_contains(PlistHandle strnode, string substr);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_KEY node against
        /// a given value.
        /// This function basically behaves like strcmp.
        /// </summary>
        /// <param name="keynode">
        /// node of type PLIST_KEY
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// > 0 if the node's value is lexicographically greater than cmpval,
        /// or
        /// <
        /// 0 if the node's value is lexicographically less than cmpval.
        /// </returns>
        int plist_key_val_compare(PlistHandle keynode, string cmpval);
        
        /// <summary>
        /// Helper function to compare the value of a PLIST_KEY node against
        /// a given value, while not comparing more than n characters.
        /// This function basically behaves like strncmp.
        /// </summary>
        /// <param name="keynode">
        /// node of type PLIST_KEY
        /// </param>
        /// <param name="cmpval">
        /// value to compare against
        /// </param>
        /// <param name="n">
        /// maximum number of characters to compare
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// > 0 if the node's value is lexicographically greater than cmpval,
        /// or
        /// <
        /// 0 if the node's value is lexicographically less than cmpval.
        /// </returns>
        int plist_key_val_compare_with_size(PlistHandle keynode, string cmpval, uint n);
        
        /// <summary>
        /// Helper function to match a given substring in the value of a
        /// PLIST_KEY node.
        /// </summary>
        /// <param name="keynode">
        /// node of type PLIST_KEY
        /// </param>
        /// <param name="substr">
        /// value to match
        /// </param>
        /// <returns>
        /// 1 if the node's value contains the given substring,
        /// or 0 if not.
        /// </returns>
        int plist_key_val_contains(PlistHandle keynode, string substr);
        
        /// <summary>
        /// Helper function to compare the data of a PLIST_DATA node against
        /// a given blob and size.
        /// This function basically behaves like memcmp after making sure the
        /// size of the node's data value is equal to the size of cmpval (n),
        /// making this a "full match" comparison.
        /// </summary>
        /// <param name="datanode">
        /// node of type PLIST_DATA
        /// </param>
        /// <param name="cmpval">
        /// data blob to compare against
        /// </param>
        /// <param name="n">
        /// size of data blob passed in cmpval
        /// </param>
        /// <returns>
        /// 0 if the node's data blob and cmpval are equal,
        /// > 0 if the node's value is lexicographically greater than cmpval,
        /// or
        /// <
        /// 0 if the node's value is lexicographically less than cmpval.
        /// </returns>
        int plist_data_val_compare(PlistHandle datanode, ref char cmpval, uint n);
        
        /// <summary>
        /// Helper function to compare the data of a PLIST_DATA node against
        /// a given blob and size, while no more than n bytes are compared.
        /// This function basically behaves like memcmp after making sure the
        /// size of the node's data value is at least n, making this a
        /// "starts with" comparison.
        /// </summary>
        /// <param name="datanode">
        /// node of type PLIST_DATA
        /// </param>
        /// <param name="cmpval">
        /// data blob to compare against
        /// </param>
        /// <param name="n">
        /// size of data blob passed in cmpval
        /// </param>
        /// <returns>
        /// 0 if the node's value and cmpval are equal,
        /// > 0 if the node's value is lexicographically greater than cmpval,
        /// or
        /// <
        /// 0 if the node's value is lexicographically less than cmpval.
        /// </returns>
        int plist_data_val_compare_with_size(PlistHandle datanode, ref char cmpval, uint n);
        
        /// <summary>
        /// Helper function to match a given data blob within the value of a
        /// PLIST_DATA node.
        /// </summary>
        /// <param name="datanode">
        /// node of type PLIST_KEY
        /// </param>
        /// <param name="cmpval">
        /// data blob to match
        /// </param>
        /// <param name="n">
        /// size of data blob passed in cmpval
        /// </param>
        /// <returns>
        /// 1 if the node's value contains the given data blob
        /// or 0 if not.
        /// </returns>
        int plist_data_val_contains(PlistHandle datanode, ref char cmpval, uint n);
        
        /// <summary>
        /// Sort all PLIST_DICT key/value pairs in a property list lexicographically
        /// by key. Recurses into the child nodes if necessary.
        /// </summary>
        /// <param name="plist">
        /// The property list to perform the sorting operation on.
        /// </param>
        void plist_sort(PlistHandle plist);
        
        /// <summary>
        /// Free memory allocated by relevant libplist API calls:
        /// - plist_to_xml()
        /// - plist_to_bin()
        /// - plist_get_key_val()
        /// - plist_get_string_val()
        /// - plist_get_data_val()
        /// </summary>
        /// <param name="ptr">
        /// pointer to the memory to free
        /// </param>
        /// <remarks>
        /// Do not use this function to free plist_t nodes, use plist_free()
        /// instead.
        /// </remarks>
        void plist_mem_free(System.IntPtr ptr);
        
        /// <summary>
        /// Set debug level for the format parsers.
        /// </summary>
        /// <param name="debug">
        /// Debug level. Currently, only 0 (off) and 1 (enabled) are supported.
        /// </param>
        /// <remarks>
        /// This function does nothing if libplist was not configured with --enable-debug .
        /// </remarks>
        void plist_set_debug(int debug);
        
        /// <summary>
        /// Returns a static string of the libplist version.
        /// </summary>
        /// <returns>
        /// The libplist version as static ascii string
        /// </returns>
        System.IntPtr libplist_version();
        
        /// <summary>
        /// Creates a FILE* given the name and mode.
        /// </summary>
        /// <param name="filename">
        /// File name.
        /// </param>
        /// <param name="mode">
        /// File mode.
        /// </param>
        /// <remarks>
        /// Used so a stream can be passed to plist_write_to_stream(). Must be closed afterwards using file_close().
        /// </remarks>
        FilePtrHandle plist_stream_file_open(string filename, string mode);
        
        /// <summary>
        /// Closes a file.
        /// </summary>
        /// <param name="file">
        /// The file to close.
        /// </param>
        /// <remarks>
        /// Used to close after a stream is passed to plist_write_to_stream().
        /// </remarks>
        int plist_stream_file_close(FilePtrHandle file);
    }
}
